name: Build and Release Binaries

on:
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to upload binaries to (optional, for testing)'
        required: false
        type: string

jobs:
  build-binaries:
    name: Build binaries for ${{ matrix.os }}-${{ matrix.arch }}
    runs-on: ${{ matrix.os }}
    
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            arch: x86_64
            target: linux
            binary_name: caffeine-linux-x86_64
          # - os: macos-latest
          #   arch: aarch64
          #   target: macos_arm
          #   binary_name: caffeine-macos-aarch64
          # - os: windows-latest
          #   arch: x86_64
          #   target: win
          #   binary_name: caffeine-windows-x86_64.exe
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup BEAM (Erlang + Gleam + rebar3)
        uses: erlef/setup-beam@v1
        with:
          otp-version: '25.3'
          gleam-version: '1.13.0'
          rebar3-version: '3.25.0'
          elixir-version: '1.17'
      
      - name: Install Burrito dependencies (zig and xz)
        run: |
          set -e
          if [[ "${{ runner.os }}" == "Linux" ]]; then
            sudo apt-get update
            sudo apt-get install -y xz-utils curl
            # Install zig 0.15.2 (required by Burrito)
            echo "Downloading zig 0.15.2..."
            ZIG_FILE="zig-x86_64-linux-0.15.2.tar.xz"
            ZIG_DIR="zig-x86_64-linux-0.15.2"
            curl -fL -o "$ZIG_FILE" "https://ziglang.org/download/0.15.2/$ZIG_FILE"
            if [ ! -f "$ZIG_FILE" ]; then
              echo "Error: Failed to download zig"
              exit 1
            fi
            echo "Extracting zig..."
            sudo tar -xf "$ZIG_FILE" -C /usr/local
            sudo ln -sf /usr/local/$ZIG_DIR/zig /usr/local/bin/zig
            rm -f "$ZIG_FILE"
          elif [[ "${{ runner.os }}" == "macOS" ]]; then
            # Install specific zig version required by Burrito
            if [[ "${{ matrix.arch }}" == "aarch64" ]]; then
              ZIG_FILE="zig-aarch64-macos-0.15.2.tar.xz"
              ZIG_DIR="zig-aarch64-macos-0.15.2"
            else
              ZIG_FILE="zig-x86_64-macos-0.15.2.tar.xz"
              ZIG_DIR="zig-x86_64-macos-0.15.2"
            fi
            curl -fL -o "$ZIG_FILE" "https://ziglang.org/download/0.15.2/$ZIG_FILE"
            if [ ! -f "$ZIG_FILE" ]; then
              echo "Error: Failed to download zig"
              exit 1
            fi
            tar -xf "$ZIG_FILE" -C /usr/local
            ln -sf /usr/local/$ZIG_DIR/zig /usr/local/bin/zig
            rm -f "$ZIG_FILE"
            brew install xz || true
          elif [[ "${{ runner.os }}" == "Windows" ]]; then
            choco install zig --version=0.15.2 xz -y
          fi
          # Verify installation
          echo "Verifying zig installation..."
          zig version
          echo "Verifying xz installation..."
          xz --version
      
      - name: Cache Gleam dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/gleam
            build
          key: ${{ runner.os }}-gleam-1.13.0-${{ hashFiles('manifest.toml') }}
          restore-keys: |
            ${{ runner.os }}-gleam-1.13.0-
            ${{ runner.os }}-gleam-
      
      - name: Download Gleam dependencies
        run: gleam deps download
      
      - name: Install Hex (required for archive installation)
        run: mix local.hex --force
      
      - name: Install mix_gleam archive (before Mix reads mix.exs)
        run: |
          echo "Installing mix_gleam archive..."
          # Install archive before Mix tries to validate mix.exs
          mix archive.install hex mix_gleam 0.6.0 --force
          echo "Verifying installation..."
          mix archive | grep mix_gleam || (echo "Archive not found after installation!" && exit 1)
      
      - name: Install Mix dependencies
        run: mix deps.get
      
      - name: Install Gleam dependencies via Mix
        run: mix gleam.deps.get
      
      - name: Build Gleam project
        run: gleam build
      
      - name: Create symlinks for Gleam dependencies (required for Mix compilation)
        run: |
          mkdir -p _build/dev/lib
          mkdir -p _build/prod/lib
          for dep in glaml gleam_stdlib gleam_erlang gleam_json gleam_otp gleeunit houdini lustre simplifile argv filepath; do
            if [ -d "build/dev/erlang/$dep" ]; then
              rm -f _build/dev/lib/$dep
              rm -f _build/prod/lib/$dep
              ln -sfn ../../../build/dev/erlang/$dep _build/dev/lib/$dep
              ln -sfn ../../../build/dev/erlang/$dep _build/prod/lib/$dep
            fi
          done
      
      - name: Clean Gleam artifact (required before Mix release)
        run: rm -f build/dev/erlang/caffeine_lang/_gleam_artefacts/gleam@@compile.erl || true
      
      - name: Build standalone binary
        run: mix release
        env:
          MIX_ENV: prod
          BURRITO_TARGET: ${{ matrix.target }}
      
      - name: Find binary path
        id: binary_path
        shell: bash
        run: |
          # Burrito creates binaries in different locations depending on the target
          # Try common locations: bin/caffeine, caffeine (root of rel), or wrapped executables
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            # Windows: look for .exe files
            BINARY_PATH=$(find _build/prod/rel/caffeine -name "*.exe" -type f | grep -E "(caffeine|burrito)" | head -n 1)
            if [[ -z "$BINARY_PATH" ]]; then
              BINARY_PATH=$(find _build/prod/rel/caffeine -name "caffeine.exe" -type f | head -n 1)
            fi
          else
            # Unix: look for executable files named caffeine or burrito-wrapped
            BINARY_PATH=$(find _build/prod/rel/caffeine -type f -executable | grep -E "(caffeine|burrito)" | head -n 1)
            if [[ -z "$BINARY_PATH" ]]; then
              BINARY_PATH=$(find _build/prod/rel/caffeine -name "caffeine" -type f -executable | head -n 1)
            fi
            if [[ -z "$BINARY_PATH" ]]; then
              # Fallback to bin directory
              BINARY_PATH="_build/prod/rel/caffeine/bin/caffeine"
            fi
          fi
          
          if [[ -z "$BINARY_PATH" ]] || [[ ! -f "$BINARY_PATH" ]]; then
            echo "Error: Binary not found. Listing _build/prod/rel/caffeine:"
            find _build/prod/rel/caffeine -type f || true
            exit 1
          fi
          
          echo "path=$BINARY_PATH" >> $GITHUB_OUTPUT
          echo "Found binary at: $BINARY_PATH"
      
      - name: Create release asset name
        id: asset_name
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            echo "name=${{ matrix.binary_name }}" >> $GITHUB_OUTPUT
          else
            echo "name=${{ matrix.binary_name }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Copy binary to workspace root
        shell: bash
        run: |
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            copy "${{ steps.binary_path.outputs.path }}" "${{ steps.asset_name.outputs.name }}"
          else
            cp "${{ steps.binary_path.outputs.path }}" "${{ steps.asset_name.outputs.name }}"
            chmod +x "${{ steps.asset_name.outputs.name }}"
          fi
      
      - name: Upload binary to release
        if: github.event_name == 'release'
        shell: bash
        run: |
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Content-Type: application/octet-stream" \
            --data-binary @"${{ steps.asset_name.outputs.name }}" \
            "${{ github.event.release.upload_url }}?name=${{ steps.asset_name.outputs.name }}"
      
      - name: Output binary location (manual run)
        if: github.event_name == 'workflow_dispatch'
        shell: bash
        run: |
          echo "Binary built at: ${{ steps.binary_path.outputs.path }}"
          echo "Copied to: ${{ steps.asset_name.outputs.name }}"
          ls -lh "${{ steps.asset_name.outputs.name }}"

